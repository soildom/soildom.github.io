<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++实现银行家算法]]></title>
    <url>%2F2018%2F11%2F16%2Fbanker-algorithm%2F</url>
    <content type="text"><![CDATA[关于银行家算法的描述，可以看看这篇博客–&gt;【操作系统】银行家算法避免死锁 废话就不多说了，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include &lt;iostream&gt;#include &lt;random&gt;#include &lt;queue&gt;using namespace std;const int m = 5;//num of Available resourcesconst int n = 5;//num of processesconst int min_sources = 10;const int max_sources = 20;int *MaxAvailable = new int[m];int *Available = new int[m];int **Max = new int *[n];int **Allocation = new int *[n];int **Need = new int *[n];bool *Finish = new bool[n];void init_max_available() &#123; default_random_engine generate(static_cast&lt;unsigned int&gt;(time(nullptr))); uniform_int_distribution&lt;int&gt; distribution(min_sources, max_sources); for (int i = 0; i &lt; m; ++i) MaxAvailable[i] = distribution(generate);&#125;void init_current_available() &#123; for (int j = 0; j &lt; m; ++j) &#123; Available[j] = MaxAvailable[j]; &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; Available[j] -= Allocation[i][j]; &#125; &#125;&#125;void init_max() &#123; for (int i = 0; i &lt; n; ++i) Max[i] = new int[m]; default_random_engine generate(static_cast&lt;unsigned int&gt;(time(nullptr))); for (int j = 0; j &lt; m; ++j) &#123; uniform_int_distribution&lt;int&gt; distribution(0, max(MaxAvailable[j] - 5, 0)); for (int i = 0; i &lt; n; ++i) Max[i][j] = distribution(generate); &#125;&#125;void init_allocation() &#123; int tmp; for (int i = 0; i &lt; n; ++i) Allocation[i] = new int[m]; default_random_engine generate(static_cast&lt;unsigned int&gt;(time(nullptr))); for (int j = 0; j &lt; m; ++j) &#123; tmp = MaxAvailable[j]; for (int i = 0; i &lt; n; ++i) &#123; uniform_int_distribution&lt;int&gt; distribution(0, min(tmp, Max[i][j])); Allocation[i][j] = distribution(generate); tmp -= Allocation[i][j]; &#125; &#125;&#125;void init_need() &#123; for (int i = 0; i &lt; n; ++i) &#123; Need[i] = new int[m]; for (int j = 0; j &lt; m; ++j) Need[i][j] = Max[i][j] - Allocation[i][j]; &#125;&#125;void init_finish() &#123; for (int i = 0; i &lt; n; ++i) Finish[i] = false;&#125;void init_all_resources() &#123; init_max_available(); init_max(); init_allocation(); init_current_available(); init_need(); init_finish();&#125;void output_max_available() &#123; cout &lt;&lt; "MaxAvailable:" &lt;&lt; endl; for (int i = 0; i &lt; m; ++i) cout &lt;&lt; MaxAvailable[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125;void output_available() &#123; cout &lt;&lt; "Available:" &lt;&lt; endl; for (int i = 0; i &lt; m; ++i) cout &lt;&lt; Available[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125;void output_max() &#123; cout &lt;&lt; endl &lt;&lt; "Max:" &lt;&lt; endl;; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; i + 1 &lt;&lt; ": "; for (int j = 0; j &lt; m; ++j) cout &lt;&lt; Max[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;void output_allocation() &#123; cout &lt;&lt; endl &lt;&lt; "Allocation:" &lt;&lt; endl;; for (int j = 0; j &lt; n; ++j) &#123; cout &lt;&lt; j + 1 &lt;&lt; ": "; for (int k = 0; k &lt; m; ++k) cout &lt;&lt; Allocation[j][k] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;void output_need() &#123; cout &lt;&lt; endl &lt;&lt; "Need:" &lt;&lt; endl;; for (int j = 0; j &lt; n; ++j) &#123; cout &lt;&lt; j + 1 &lt;&lt; ": "; for (int k = 0; k &lt; m; ++k) cout &lt;&lt; Need[j][k] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;void output_all_resources() &#123; output_max_available(); output_available(); output_max(); output_allocation(); output_need();&#125;bool isSafe() &#123; bool flag; queue&lt;int&gt; tmp_queue; unsigned long queue_size = 0; int *tmp_available = new int[m]; for (int j = 0; j &lt; m; ++j) tmp_available[j] = Available[j]; while (true) &#123; for (int i = 0; i &lt; n; ++i) &#123; if (Finish[i]) continue; //Find processes that can run with the available resources flag = true; for (int j = 0; j &lt; m; ++j) &#123; if (Need[i][j] &gt; tmp_available[j]) &#123; flag = false; break; &#125; &#125; if (!flag) continue; Finish[i] = true; for (int j = 0; j &lt; m; ++j) tmp_available[j] += Allocation[i][j]; tmp_queue.push(i + 1); &#125; if (tmp_queue.size() == queue_size) break; queue_size = tmp_queue.size(); &#125; cout &lt;&lt; endl &lt;&lt; queue_size &lt;&lt; "个进程可行:" &lt;&lt; endl; while (!tmp_queue.empty()) &#123; cout &lt;&lt; tmp_queue.front() &lt;&lt; ' '; tmp_queue.pop(); &#125; delete[] tmp_available; return queue_size == n;&#125;bool request_resources(int process_number, int Request[]) &#123; cout &lt;&lt; endl &lt;&lt; process_number + 1 &lt;&lt; "号进程向系统请求资源："; for (int j = 0; j &lt; m; ++j) cout &lt;&lt; Request[j] &lt;&lt; ' '; cout &lt;&lt; endl; for (int j = 0; j &lt; m; ++j) &#123; if (Request[j] &gt; Need[process_number][j]) &#123; cout &lt;&lt; "请求资源超过它所需的最大值("; for (int jj = 0; jj &lt; m; ++jj) cout &lt;&lt; Need[process_number][jj] &lt;&lt; ' '; cout &lt;&lt; ")，不予以分配！" &lt;&lt; endl; return false; &#125; &#125; for (int j = 0; j &lt; m; ++j) &#123; if (Request[j] &gt; Available[j]) &#123; cout &lt;&lt; "尚无足够资源，需等待..." &lt;&lt; endl; return false; &#125; &#125; for (int j = 0; j &lt; m; ++j) &#123; Available[j] -= Request[j]; Allocation[process_number][j] += Request[j]; Need[process_number][j] -= Request[j]; &#125; if (isSafe()) &#123; cout &lt;&lt; "系统安全，允许分配资源" &lt;&lt; endl; return true; &#125; else &#123; cout &lt;&lt; "系统不安全，此次分配需等待..." &lt;&lt; endl; for (int j = 0; j &lt; m; ++j) &#123; Available[j] += Request[j]; Allocation[process_number][j] -= Request[j]; Need[process_number][j] += Request[j]; &#125; return false; &#125;&#125;int main() &#123; init_all_resources(); output_all_resources(); int *request = new int[m]; int process_number; default_random_engine generate(static_cast&lt;unsigned int&gt;(time(nullptr))); uniform_int_distribution&lt;int&gt; resources_distribution(0, 1); uniform_int_distribution&lt;int&gt; num_distribution(0, n - 1); for (int j = 0; j &lt; m; ++j) request[j] = resources_distribution(generate); process_number = num_distribution(generate); request_resources(process_number, request); return 0;&#125;]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2018%2F10%2F31%2Ftree-array%2F</url>
    <content type="text"><![CDATA[最近在做算法分析与设计的课程设计，题目如下~~ 给你一个1000×1000的𝑏𝑜𝑜𝑙矩阵，初始时所有元素为0 给你一个矩形的左上角和右下角坐标，将矩形内的元素置反，即0–&gt;1，1–&gt;0（包括边界） 给你一个点的坐标(𝑥,𝑦)，询问当前点的𝑏𝑜𝑜𝑙值 两种操作交替执行 原题点这里–&gt;传送门 我们先做个约束： $ M=1000={矩阵的大小} $ $ T={数据的组数} $ $ N={置反的次数} $ 暴力求解首先，我们的第一思路肯定是创建一个1000×1000的二维𝑏𝑜𝑜𝑙数组，用来记录这个矩阵当前的𝑏𝑜𝑜𝑙值。每次置反时，遍历整个矩形区域。然而，它的时间复杂度是 $ O(M^2NT)=O(5\times10^{11}) $，所以这个方法肯定不行 树状数组隆重登场~~ 树状数组$lobit$函数定义首先需要介绍一下$lobit$函数，它的作用是将一个十进制数转为二进制后，输出它的（从右往左数）第一个“1”所在位置代表的十进制数。例如：$$ 34_{(10)}=00100010_{(2)} $$$$ lobit(34_{(10)})=00000010_{(2)}=2_{(10)} $$ 实现123int lowbit(int x) &#123; return x&amp;(-x);&#125; 在树状数组中的作用$\forall x\ge1$，$lobit(x)$表示$x$所能管到的区间长度，且$x$所能管到的区间长度为$[x-lobit(x)+1,x]$。如上例中$34$能管到的区间长度为$2$，它能管到的区间是$[33,34]$。 树状数组的意义一维树状数组定义 给定一个普通数组$a[n]$$(n\ge1)$和它的树状数组$t[n]$$(n\ge1)$，$\forall i (1\le i\le n)$：我们知道，$a[i]$表示数组$a$的第$i$个值，而$$t[n]=\sum_{k=i-lobit(i)+1}^{i}a[k]$$ (单点)更新若我们更新原数组$a[n]$中的某个值，则树状数组$t[n]$中所有能管到$a[n]$的元素也必须更新，并且我们可以通过$lobit$函数找到所有能管到它的节点 1234void update(int x, int k) &#123; for (int i=x; i&lt;=N; i+=lowbit(i)) t[i]+=k;&#125; (区间)询问给定$x\ge1$，则$$ query(x)=\sum_{i=1}^{x}a[i] $$同样地，我们还是需要$lobit$函数来实现 123456int query(int x) &#123; int ans=0; for (int i=x; i&gt;0; i-=lowbit(i)) ans+=t[i]; return ans;&#125; (区间)更新区间更新指的是对一段连续的区间$[c,d]$进行更新（都减去相同的值或都加上相同的值），如果调用$(d-c+1)$次单点更新函数，那时间复杂度将会是$O((d-c+1)\log n)$这里，需要对原数组$a[n]$做个转换，引入差分数组$b[n]$$$b[1]=a[1]$$$$b[2]=a[2]-a[1]$$$$b[3]=a[3]-a[2]$$$$…$$$$b[n]=a[n]-a[n-1]$$若对$a[n]$中区间$[c,d]$进行更新（以这段区间同时$+k$为例），则$b[n]$中变动的只有$b[c]$和$b[d+1]$，其中$$b[c]+=k，b[d+1]-=k$$这样一来，我们只需调用$2$次单点更新函数就行了，还把时间复杂度降到了$O(2\log n)$ (单点)询问与上面区间更新对应，从而有了单点询问，定义$a[0]=0$，对差分数组$b[n]$，我们有$$query(x)=\sum_{i=1}^{x}b[i]=\sum_{i=1}^{x}(a[i]-a[i-1])=a[x]$$故只需对差分数组$b[n]$调用一次区间询问函数就能求得原数组$a[n]$中的$a[x]$ 二维树状数组未完待续~~~]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS下GitHub+Hexo个人博客搭建]]></title>
    <url>%2F2018%2F10%2F17%2Fgithub%2Bhexo%2F</url>
    <content type="text"><![CDATA[第一次搭建自己的博客，趁还没忘赶紧记录下搭建过程~~ 注册GitHub既然你搜到这篇文章那十有八九已经拥有自己的GitHub账号了吧。。。什么？！你还没有GitHub，不管了，反正GitHub又没被墙，自己去注册吧(～￣▽￣)～ 新建仓库（Repository）登录你的GitHub账号，点击右上角的“+”，然后点击 New repository ，出现下图中的页面在 Repository name 中输入 yourname.github.io ，把 yourname 更改为你的名字或昵称，这里以 yourname.github.io 为例。最后点击页面底部的 Create repository 按钮就完成创建了。 环境配置安装Git 这里可以参看Git 教程| 菜鸟教程 安装Node.js 进入Node.js®官网下载，打开.pkg文件，根据提示进行安装 安装Hexo安装到终端执行以下命令1$ npm install -g hexo-cli 如果因为权限问题报错，则执行以下命令1$ sudo npm install -g hexo 初始化cd 到你希望储存的目录下，执行以下命令（ps： ⌥+⌘+C 可以拷贝当前文件夹路径到粘贴板）1$ hexo init example 其中 example 是你文件夹的名称 cd 到 example 文件夹下，执行以下命令1$ npm install 运行服务器cd 到 example 文件夹下，执行以下命令1$ hexo server or1$ hexo s 此时在浏览器中输入http://localhost:4000,就能看到你的博客啦~~~更多信息: Server 关联GitHub到刚刚的 example 文件夹下，打开 _config.yml ，找到“deploy”字段，修改为下面的样子：1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 生成静态文件cd 到 example 文件夹下，执行以下命令1$ hexo generate or1$ hexo g 更多信息: Generating 部署到GitHub1$ hexo deploy or1$ hexo d 更多信息: Deployment此时，若你未关联GitHub，则执行上述命令时终端会提示你输入GitHub的用户名和密码，只需按照提示输入即可。执行成功后，在浏览器打开http://yourname.github.io，就能看到刚刚的个人主页啦~~ 更换主题Hexo有很多开源主题，这里我们以 NexT 为例进行介绍cd 到 example 文件夹下，执行以下命令 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 这条命令的意思是将 NexT 主题下载到 ~/example/themes/next 目录下然后在 example 目录下找到名为 _config.yml 文件，并将该文件中的 theme 字段下的 landscape 更改为 next cd 到 example 文件夹下，依次执行以下命令12345$ hexo clean$ hexo g$ hexo d 执行成功后，在浏览器打开http://yourname.github.io，就能看到新的主题啦~~当然，你也可以执行1$ hexo g 在http://localhost:4000进行本地预览 绑定个人域名你现在的域名是http://yourname.github.io，如果你想换成自己的个性化域名（如： yourname.com ）,那你就需要购买一个域名，国内的话我推荐腾讯云和阿里云。下面以腾讯云为例进行介绍 为你的域名添加如下图所示的三条解析注：将第一条解析中的记录值 soildom.github.io. 改为 yourname.github.io. (别忘了加最后的 .)后两条解析的作用在于可使你的域名获得HTTPS认证 到 ~/example/themes/next/source 目录下新建名为： CNAME (无后缀名)的文件，并将你的域名 yourname.com 写入该文件 cd 到 example 文件夹下，依次执行以下命令12345$ hexo clean$ hexo g$ hexo d 大功告成，现在在浏览器打开https://yourname.com，就能看到你的博客啦~~ 相关阅读 Hexo NexT hexo提交搜索引擎（百度+谷歌） 把博客同时部署到github和coding上 部署到github和coding上的hexo的个人博客绑定同一域名 CodingPages申请SSL/TLS证书错误 Hexo+Next主题优化]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
